---
---
*  `const`类型必须在初始化时赋值，不能用**字面常量**和**临时变量**对**常引用**初始化。
*  指向常量的指针和常指针
<br/>```const int* p = &i; // 指向常量的指针，冻结指针变量所指数据```
<br/>```int* const p = &i; // 常指针，冻结指针地址```
<br/>```const int* const p = &i; // 指向常量的常指针```
*  `const`修饰返回类型时，必须由`const`类型承接
*  `const`修饰成员函数，不允许该成员函数修改对象的成员变量。
*  只有数组的引用（eg. ```int (&a)[10] = b;```）
<br/>没有引用的数组，引用不能作为数组元素
*  指向常量的指针做右值，左值也必须是指向常量的指针，才能保证所指内容不被修改
<br/>```const A* a = new A;```
<br/>```A* b = a; // 错```
<br/>```const A* c = a; // 对```
*  函数返回引用时，应注意被引用变量是否已经消亡
*  内联（`inline`）函数中不能*含有循环*、*`switch`语句*、*静态变量*、*递归函数*、*异常处理*，且不要太长（一般5行以内）
*  默认参数值必须在函数声明中指定，不能写在定义中，除非没有声明。定义必须遵守从右到左的顺序，不能时局部变量。
*  函数的功能应单一，且应降低对环境的依赖性，降低耦合度，不要返回局部变量的引用或指针
*  成员变量不可声明为`extern`、`register`，可以是`static`或`const`
*  对象访问是类外访问，不能直接访问`private`成员
*  调用构造函数
<br/>```Clock myClock; // 隐含调用构造函数，创建有名对象```
<br/>```Clock* p = new Clock; // 显式调用构造函数，创建无名对象```
*  构造函数不可为常函数，也不可为虚函数
*  对象的初始化由**构造函数**承担
<br/>数据成员的初始化由**初始化列表**承担
<br/>只有**构造**和**拷贝构造**可以用初始化列表
<br/>注意：构造函数内部已不再是初始化，而是赋值
*  没有无参构造时，类的组合和继承，引用成员变量和常成员变量的初始化必须使用初始化列表
*  初始化列表应按类声明时的顺序写
<br/>先继承、再组合、再自身
*  拷贝构造的调用
    *  ```Point a(b)```
    *  通过函数调用时传参（副本）
    *  返回值返回的时副本时
*  不要让构造函数做与创建对象、初始化对象无关的事
*  静态成员变量
<br/>主要用来充当信号量
<br/>所有对象维护一套副本，不能继承
<br/>不能在构造函数中初始化，应在类外
<br/>调用时，只能用`类名::`
*  静态成员函数
<br/>定义时不需要写`static`（声明时写即可）
<br/>只能访问静态成员函数和静态成员变量
<br/>不能访问非静态（因为静态成员函数无`this`）
*  组合时，若需要拷贝构造，则应编写初始化列表，否则系统调用的将是无参构造，而非拷贝构造
*  尽量不使用或少使用友元
*  被组合的类，必须有无参构造
*  常成员函数对本类成员只读不写（`const`实际是修饰this的）
*  类中成员函数无需变化时，用组合；
<br/>需要变化（eg.数组长度）时，用聚合（聚合方法：数据成员用指针或引用）；
*  指针和数组
```
int a[10]; // ``` 等价于 ```int* const a;
int b[8][9]; // ``` 等价于 ```int (* const b)[9];
```
*  指针型函数
<br/>返回值是地址
<br/>格式：```数据类型* 函数名()```
*  在函数调用时，一定注意返回值是否有效，或是否是对实参本身进行操作
*  尽量使用传址，少用传值
*  指向函数的指针
```
数据类型 (*函数指针名)(形参表);
```
*  指向函数的指针数组
```
数据类型 (*函数指针名[])(形参表);
```
*  若成员函数的返回值都是对象（或引用），则可使用成员函数的连续调用
*  指向成员的指针，名曰指针，实则是以对象首地址为准的偏移量
*  指向多维数组的指针不可初始化
*  聚集时，拷贝构造和赋值函数必须重写（深拷贝，拷贝指针所指向对象地址，而非指针本身）
<br/>在构造函数中一定要对指针初始化，可以写NULL
*  赋值函数应避免自赋值，即判断 ```this != &形参;```
<br/>返回值用`&`是最好的选择（可以连续赋值）
*  聚集除可用指针外，还可用引用
*  继承中，派生类对基类的成员，除“三大件”和静态成员外，全盘接收，特别注意，静态成员不参与继承
*  `private`继承（只是作用于外部访问，不影响派生类对基类的访问）
<br/>基类中的`public`和`protected`成员都以`private`身份出现在派生类中，派生类的对象也因此不能直接访问基类中的任何成员（对象访问是外部访问），派生类中的成员可直接访问基类中的`public`和`protected`成员，不能直接访问`private`成员。
*  `protected`继承（只是作用于外部访问，不影响派生类对基类的访问）
<br/>基类中的`public`和`protected`成员都以`protected`身份出现在派生类中
<br/>（其他与`private`继承规则相同）
*  “打捞”访问权限
<br/>在`private`继承和`protected`继承中，可以在派生类中使用 ```using 类名::成员名```的方式，将访问权限“打捞”，使其保持不变。
但注意：
    *  “打捞”不能区分重载
    *  只能还原访问级别，不能提升
    *  只能还原直接基类，不能“隔代”打捞
    *  不能让子类孙类重复打捞
*  类型兼容规则（不能用在数组上，因为指针指向对象数组会造成错位）
<br/>大概念可以拥有小概念的所有东西
    * 派生类对象可以被赋值给基类对象
<br/>真切割，“表面类型”和“真实类型”一致。
    * 派生类对象可以初始化基类的引用
    * 指向基类的指针可以指向派生类对象
<br/>假切割，“表面类型”和“真实类型”不一致，发生“强转”
*  多继承后，尽管用指针指向各类对象，但“切割”作用使子类同名函数仍不能被调用
*  同名二义性：用同名覆盖解决，访问被覆盖的成员要用::
*  路径二义性：用虚基类解决（虚继承），虚基类的成员存储在最后，只有一个。
*  虚拟继承中，会在派生类的对象中自动添加一个`vbptr`指针，指向一个类维护的、全体对象共享的`vbtable`（偏移量类），是个数组。`vbtable`的第一项为`vbptr`相对于该类对象的首地址的偏移量（通常为0），第二项为虚基类成员的偏移量
*  如果有虚基类，则应先调用虚基类的构造函数
*  多虚继承时，访问全县“就低不就高”
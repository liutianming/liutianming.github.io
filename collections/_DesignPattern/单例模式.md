---
---

## 定义

确保一个类只有一个实例，并提供一个全局访问点。

## 单利模式的进化

### 1. 最简单的单例模式(非线程安全的)

```Java
public class Dan {
    public static Dan instance = null;
    public static Dan getInstance() {
        if (instance == null) {
            instance = new Dan();
        }
        return instance;
    }
    private Dan() {}
}
```

#### [存在的问题]

这个形式仅可用于单线程。<br/>
如果多个线程同时调用`getInstance()`，则完全有可能实例化多个`Dan`对象。<br/>
例如，<br/>
在执行`instance = new Dan();`之前，几个线程都执行完了`if (instance == null)`判断，则这几个线程都可以执行`instance = new Dan();`。<br/>

### 2. 使用同步synchronized(影响性能)

```Java
public class Dan {
    public static Dan instance = null;
    public static synchronized Dan getInstance() {
        if (instance == null) {
            instance = new Dan();
        }
        return instance;
    }
    private Dan() {}
}
```
使用 **`synchronized`** 关键字，加一道线程锁。<br/>
**`synchronized`** 关键字迫使每个线程在进入`getInstance()`方法之前，要先等候别的县城离开该方法。也就是说不会有两个线程同时进入这个方法。<br/>

#### [存在的问题]

`synchronized`关键字会降低性能。<br/>
而且只有第一次执行`getInstance()`方法时，才需要同步。之后的每次调用，同步都是一种累赘。<br/>

### 3. 急切创建

```Java
public class Dan {
    public static Dan instance = new Dan();
    public static Dan getInstance() {
        return instance;
    }
    private Dan() {}
}
```

JVM会在加载这个类时立即创建单利对象。<br/>

### 4. 双重检查锁

```Java
public class Dan {
    public volatile static Dan instance;
    public static Dan getInstance() {
        if (instance == null) {
            synchronized (Dan.class) {
                if (instance == null) {
                    instance = new Dan();
                }
            }
        }
        return instance;
    }
    private Dan() {}
}
```
使用`synchronized`就可以处理线程安全问题。<br/>
个人理解加`volatile`是为了优化性能。<br/>
使用`volatile`关键字，可以确保单利对象初始化后，多个线程能正确地处理单利对象。<br/>
> volatile让变量每次在使用的时候，都从主存中取。而不是从各个线程的“工作内存”。
volatile具有synchronized关键字的“可见性”，但是没有synchronized关键字的“并发正确性”，也就是说不保证线程执行的有序性。
也就是说，volatile变量对于每次使用，线程都能得到当前volatile变量的最新值。但是volatile变量并不保证并发的正确性。
在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。
一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。
